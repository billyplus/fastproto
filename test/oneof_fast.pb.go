// Code generated by protoc-gen-go-fast. DO NOT EDIT.
// versions:
//  protoc-gen-go-fast v0.0.1
//  protoc             v4.25.3
// source: test/oneof.proto

package test

import (
	bytes "bytes"
	fmt "fmt"
	fastproto "github.com/billyplus/fastproto"
	protohelper "github.com/billyplus/fastproto/protohelper"
	pb "github.com/billyplus/fastproto/test/pb"
	protowire "google.golang.org/protobuf/encoding/protowire"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	math "math"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the packages it is being compiled against.
var _ = fmt.Errorf
var _ = math.MaxFloat32
var _ = protowire.MinValidNumber
var _ = protohelper.Skip
var _ = protoimpl.MinVersion

func (x *OneOfProto) XxxReset() {
	*x = OneOfProto{}
}

func (x *OneOfProto) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: OneOfProto: illegal tag %d (wire type %d)", num, wireType)
		}
		prev := data
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VInt32", wireType)
			}
			v, n := protohelper.ConsumeVarint[int32](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VInt32{VInt32: v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VInt64", wireType)
			}
			v, n := protohelper.ConsumeVarint[int64](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VInt64{VInt64: v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VUint32", wireType)
			}
			v, n := protohelper.ConsumeVarint[uint32](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VUint32{VUint32: v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VUint64", wireType)
			}
			v, n := protohelper.ConsumeVarint[uint64](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VUint64{VUint64: v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VString", wireType)
			}
			v, n := protohelper.ConsumeString(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VString{VString: string(v)}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBytes", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VBytes{VBytes: v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBool", wireType)
			}
			v, n := protohelper.ConsumeBool(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_VBool{VBool: v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SInt32", wireType)
			}
			v, n := protohelper.ConsumeSint[int32](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_SInt32{SInt32: v}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SInt64", wireType)
			}
			v, n := protohelper.ConsumeSint[int64](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_SInt64{SInt64: v}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32", wireType)
			}
			v, n := protohelper.ConsumeFixed32[uint32](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_Fixed32{Fixed32: v}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64", wireType)
			}
			v, n := protohelper.ConsumeFixed64[uint64](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_Fixed64{Fixed64: v}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32", wireType)
			}
			v, n := protohelper.ConsumeFixed32[int32](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_Sfixed32{Sfixed32: v}
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64", wireType)
			}
			v, n := protohelper.ConsumeFixed64[int64](data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_Sfixed64{Sfixed64: v}
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float32", wireType)
			}
			v, n := protohelper.ConsumeFloat32(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_Float32{Float32: v}
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64", wireType)
			}
			v, n := protohelper.ConsumeFloat64(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &OneOfProto_Float64{Float64: v}
		case 231:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MActor", wireType)
			}
			vv := &OtherMessage{}
			if n, err := protohelper.ConsumeMessage(data, vv); err != nil {
				return err
			} else {
				x.TestOneof = &OneOfProto_MActor{MActor: vv}
				data = data[n:]
			}
		case 281:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outer", wireType)
			}
			vv := &pb.OuterMsg{}
			if n, err := protohelper.ConsumeMessage(data, vv); err != nil {
				return err
			} else {
				x.TestOneof = &OneOfProto_Outer{Outer: vv}
				data = data[n:]
			}
		default:
			n, err := protohelper.Skip(prev[:])
			if err != nil {
				return err
			}
			x.unknownFields = append(x.unknownFields, prev[:n]...)
			data = prev[n:]
		}
	}
	return nil
}

func (x *OneOfProto) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(OneOfProto)")
	}
	return len(data), nil
}

func (x *OneOfProto) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *OneOfProto) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	switch vv := x.GetTestOneof().(type) {
	case *OneOfProto_VInt32:
		if vv.VInt32 != 0 {
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(vv.VInt32))
		}
	case *OneOfProto_VInt64:
		if vv.VInt64 != 0 {
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(vv.VInt64))
		}
	case *OneOfProto_VUint32:
		if vv.VUint32 != 0 {
			data = protowire.AppendVarint(data, 24)
			data = protowire.AppendVarint(data, uint64(vv.VUint32))
		}
	case *OneOfProto_VUint64:
		if vv.VUint64 != 0 {
			data = protowire.AppendVarint(data, 32)
			data = protowire.AppendVarint(data, uint64(vv.VUint64))
		}
	case *OneOfProto_VString:
		if len(vv.VString) > 0 {
			data = protowire.AppendVarint(data, 42)
			data = protowire.AppendVarint(data, uint64(len(vv.VString)))
			data = append(data, vv.VString...)
		}
	case *OneOfProto_VBytes:
		if len(vv.VBytes) > 0 {
			data = protowire.AppendVarint(data, 186)
			data = protowire.AppendVarint(data, uint64(len(vv.VBytes)))
			data = append(data, vv.VBytes...)
		}
	case *OneOfProto_VBool:
		if vv.VBool {
			data = protowire.AppendVarint(data, 48)
			data = append(data, uint8(protohelper.Bool2Int(vv.VBool)))
		}
	case *OneOfProto_SInt32:
		if vv.SInt32 != 0 {
			data = protowire.AppendVarint(data, 56)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(vv.SInt32)))
		}
	case *OneOfProto_SInt64:
		if vv.SInt64 != 0 {
			data = protowire.AppendVarint(data, 64)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(vv.SInt64)))
		}
	case *OneOfProto_Fixed32:
		if vv.Fixed32 != 0 {
			data = protowire.AppendVarint(data, 77)
			data = protowire.AppendFixed32(data, uint32(vv.Fixed32))
		}
	case *OneOfProto_Fixed64:
		if vv.Fixed64 != 0 {
			data = protowire.AppendVarint(data, 81)
			data = protowire.AppendFixed64(data, uint64(vv.Fixed64))
		}
	case *OneOfProto_Sfixed32:
		if vv.Sfixed32 != 0 {
			data = protowire.AppendVarint(data, 93)
			data = protowire.AppendFixed32(data, uint32(vv.Sfixed32))
		}
	case *OneOfProto_Sfixed64:
		if vv.Sfixed64 != 0 {
			data = protowire.AppendVarint(data, 97)
			data = protowire.AppendFixed64(data, uint64(vv.Sfixed64))
		}
	case *OneOfProto_Float32:
		if vv.Float32 != 0 {
			data = protowire.AppendVarint(data, 165)
			data = protowire.AppendFixed32(data, uint32(math.Float32bits(vv.Float32)))
		}
	case *OneOfProto_Float64:
		if vv.Float64 != 0 {
			data = protowire.AppendVarint(data, 169)
			data = protowire.AppendFixed64(data, uint64(math.Float64bits(vv.Float64)))
		}
	case *OneOfProto_MActor:
		if vv.MActor != nil {
			data = protowire.AppendVarint(data, 1850)
			sz := uint64(fastproto.Size(vv.MActor))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, vv.MActor)
				if err != nil {
					return nil, err
				}
			}
		}
	case *OneOfProto_Outer:
		if vv.Outer != nil {
			data = protowire.AppendVarint(data, 2250)
			sz := uint64(fastproto.Size(vv.Outer))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, vv.Outer)
				if err != nil {
					return nil, err
				}
			}
		}
	default:
	}
	return data, nil
}

func (x *OneOfProto) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*OneOfProto)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false {
		return false
	}
	if false {
		return false
	}
	switch xx := x.GetTestOneof().(type) {
	case *OneOfProto_VInt32:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VInt32); !ok {
			return false
		} else if vv2.VInt32 != xx.VInt32 {
			return false
		}
	case *OneOfProto_VInt64:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VInt64); !ok {
			return false
		} else if vv2.VInt64 != xx.VInt64 {
			return false
		}
	case *OneOfProto_VUint32:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VUint32); !ok {
			return false
		} else if vv2.VUint32 != xx.VUint32 {
			return false
		}
	case *OneOfProto_VUint64:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VUint64); !ok {
			return false
		} else if vv2.VUint64 != xx.VUint64 {
			return false
		}
	case *OneOfProto_VString:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VString); !ok {
			return false
		} else if vv2.VString != xx.VString {
			return false
		}
	case *OneOfProto_VBytes:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VBytes); !ok {
			return false
		} else if !bytes.Equal(vv2.VBytes, xx.VBytes) {
			return false
		}
	case *OneOfProto_VBool:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_VBool); !ok {
			return false
		} else if vv2.VBool != xx.VBool {
			return false
		}
	case *OneOfProto_SInt32:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_SInt32); !ok {
			return false
		} else if vv2.SInt32 != xx.SInt32 {
			return false
		}
	case *OneOfProto_SInt64:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_SInt64); !ok {
			return false
		} else if vv2.SInt64 != xx.SInt64 {
			return false
		}
	case *OneOfProto_Fixed32:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Fixed32); !ok {
			return false
		} else if vv2.Fixed32 != xx.Fixed32 {
			return false
		}
	case *OneOfProto_Fixed64:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Fixed64); !ok {
			return false
		} else if vv2.Fixed64 != xx.Fixed64 {
			return false
		}
	case *OneOfProto_Sfixed32:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Sfixed32); !ok {
			return false
		} else if vv2.Sfixed32 != xx.Sfixed32 {
			return false
		}
	case *OneOfProto_Sfixed64:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Sfixed64); !ok {
			return false
		} else if vv2.Sfixed64 != xx.Sfixed64 {
			return false
		}
	case *OneOfProto_Float32:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Float32); !ok {
			return false
		} else if vv2.Float32 != xx.Float32 {
			return false
		}
	case *OneOfProto_Float64:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Float64); !ok {
			return false
		} else if vv2.Float64 != xx.Float64 {
			return false
		}
	case *OneOfProto_MActor:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_MActor); !ok {
			return false
		} else if !fastproto.Equal(vv2.MActor, xx.MActor) {
			return false
		}
	case *OneOfProto_Outer:
		if vv2, ok := vv.GetTestOneof().(*OneOfProto_Outer); !ok {
			return false
		} else if !fastproto.Equal(vv2.Outer, xx.Outer) {
			return false
		}
	default:
	}
	return true
}

func (x *OneOfProto) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	switch vv := x.GetTestOneof().(type) {
	case *OneOfProto_VInt32:
		if vv.VInt32 != 0 {
			n += 1 + protowire.SizeVarint(uint64(vv.VInt32))
		}
	case *OneOfProto_VInt64:
		if vv.VInt64 != 0 {
			n += 1 + protowire.SizeVarint(uint64(vv.VInt64))
		}
	case *OneOfProto_VUint32:
		if vv.VUint32 != 0 {
			n += 1 + protowire.SizeVarint(uint64(vv.VUint32))
		}
	case *OneOfProto_VUint64:
		if vv.VUint64 != 0 {
			n += 1 + protowire.SizeVarint(uint64(vv.VUint64))
		}
	case *OneOfProto_VString:
		l = len(vv.VString)
		if l > 0 {
			n += 1 + protowire.SizeBytes(l)
		}
	case *OneOfProto_VBytes:
		l = len(vv.VBytes)
		if l > 0 {
			n += 2 + protowire.SizeBytes(l)
		}
	case *OneOfProto_VBool:
		if vv.VBool {
			n += 2
		}
	case *OneOfProto_SInt32:
		if vv.SInt32 != 0 {
			n += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(vv.SInt32)))
		}
	case *OneOfProto_SInt64:
		if vv.SInt64 != 0 {
			n += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(vv.SInt64)))
		}
	case *OneOfProto_Fixed32:
		if vv.Fixed32 != 0 {
			n += 1 + 4
		}
	case *OneOfProto_Fixed64:
		if vv.Fixed64 != 0 {
			n += 1 + 8
		}
	case *OneOfProto_Sfixed32:
		if vv.Sfixed32 != 0 {
			n += 1 + 4
		}
	case *OneOfProto_Sfixed64:
		if vv.Sfixed64 != 0 {
			n += 1 + 8
		}
	case *OneOfProto_Float32:
		if vv.Float32 != 0 {
			n += 2 + 4
		}
	case *OneOfProto_Float64:
		if vv.Float64 != 0 {
			n += 2 + 8
		}
	case *OneOfProto_MActor:
		if vv.MActor != nil {
			n += 2 + protowire.SizeBytes(fastproto.Size(vv.MActor))
		}
	case *OneOfProto_Outer:
		if vv.Outer != nil {
			n += 2 + protowire.SizeBytes(fastproto.Size(vv.Outer))
		}
	default:
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}
