// Code generated by protoc-gen-go-fast. DO NOT EDIT.
// versions:
//  protoc-gen-go-fast v0.0.1
//  protoc             v3.15.8
// source: test/msg.proto

package test

import (
	bytes "bytes"
	fmt "fmt"
	fastproto "github.com/billyplus/fastproto"
	protohelper "github.com/billyplus/fastproto/protohelper"
	pb "github.com/billyplus/fastproto/test/pb"
	protowire "google.golang.org/protobuf/encoding/protowire"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	math "math"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the packages it is being compiled against.
var _ = fmt.Errorf
var _ = math.MaxFloat32
var _ = protowire.MinValidNumber
var _ = protohelper.Skip
var _ = protoimpl.MinVersion

func (x *EmptyMsg) XxxReset() {
	*x = EmptyMsg{}
}

func (x *EmptyMsg) Unmarshal(data []byte) error {
	if len(data) > 0 {
		x.unknownFields = append(x.unknownFields, data[:]...)
	}
	return nil
}

func (x *EmptyMsg) MarshalTo(data []byte) (n int, err error) {
	return 0, nil
}

func (x *EmptyMsg) Marshal() ([]byte, error) {
	return []byte{}, nil
}

func (x *EmptyMsg) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	return data, nil
}

func (x *EmptyMsg) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*EmptyMsg)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	return true
}

func (x *EmptyMsg) Size() (n int) {
	return
}

func (x *FullProto) XxxReset() {
	*x = FullProto{}
}

func (x *FullProto) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: FullProto: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VInt32", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VInt32 = int32(v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VInt64", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VInt64 = int64(v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VUint32", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VUint32 = uint32(v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VUint64", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VUint64 = uint64(v)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VString", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VString = string(v)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBytes", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VBytes = append(x.VBytes[:0], v...)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBool", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.VBool = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SInt32", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.SInt32 = int32(protowire.DecodeZigZag(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SInt64", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.SInt64 = int64(protowire.DecodeZigZag(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32", wireType)
			}
			v, n := protowire.ConsumeFixed32(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Fixed32 = uint32(v)
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64", wireType)
			}
			v, n := protowire.ConsumeFixed64(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Fixed64 = uint64(v)
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32", wireType)
			}
			v, n := protowire.ConsumeFixed32(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Sfixed32 = int32(v)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64", wireType)
			}
			v, n := protowire.ConsumeFixed64(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Sfixed64 = int64(v)
		case 41:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.ArrInt32 = append(x.ArrInt32, int32(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.ArrInt32) == 0 {
					x.ArrInt32 = make([]int32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.ArrInt32 = append(x.ArrInt32, int32(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrInt32", wireType)
			}
		case 42:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.ArrInt64 = append(x.ArrInt64, int64(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.ArrInt64) == 0 {
					x.ArrInt64 = make([]int64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.ArrInt64 = append(x.ArrInt64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrInt64", wireType)
			}
		case 43:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.ArrUint32 = append(x.ArrUint32, uint32(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.ArrUint32) == 0 {
					x.ArrUint32 = make([]uint32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.ArrUint32 = append(x.ArrUint32, uint32(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrUint32", wireType)
			}
		case 44:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.ArrUint64 = append(x.ArrUint64, uint64(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.ArrUint64) == 0 {
					x.ArrUint64 = make([]uint64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.ArrUint64 = append(x.ArrUint64, uint64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrUint64", wireType)
			}
		case 45:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.ArrBool = append(x.ArrBool, v != 0)
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen
				if elementCount != 0 && len(x.ArrBool) == 0 {
					x.ArrBool = make([]bool, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.ArrBool = append(x.ArrBool, v != 0)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrBool", wireType)
			}
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrString", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.ArrString = append(x.ArrString, string(v))
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrBytes", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.ArrBytes = append(x.ArrBytes[:], append([]byte{}, v...))
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Bool", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt32Bool == nil {
				x.MapInt32Bool = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = bool(v != 0)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt32Bool[mapkey] = mapvalue
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Int32", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt32Int32 == nil {
				x.MapInt32Int32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int32(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt32Int32[mapkey] = mapvalue
		case 83:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32String", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt32String == nil {
				x.MapInt32String = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = string(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt32String[mapkey] = mapvalue
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Bool", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt64Bool == nil {
				x.MapInt64Bool = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = bool(v != 0)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt64Bool[mapkey] = mapvalue
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Int64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt64Int64 == nil {
				x.MapInt64Int64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt64Int64[mapkey] = mapvalue
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Bytes", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt64Bytes == nil {
				x.MapInt64Bytes = make(map[int64][]byte)
			}
			var mapkey int64
			var mapvalue []byte
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = []byte(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt64Bytes[mapkey] = mapvalue
		case 121:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint32Sint64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapSint32Sint64 == nil {
				x.MapSint32Sint64 = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(protowire.DecodeZigZag(v))
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(protowire.DecodeZigZag(v))
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapSint32Sint64[mapkey] = mapvalue
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint64Sint32", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapSint64Sint32 == nil {
				x.MapSint64Sint32 = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(protowire.DecodeZigZag(v))
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int32(protowire.DecodeZigZag(v))
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapSint64Sint32[mapkey] = mapvalue
		case 161:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed32Sfixed64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapFixed32Sfixed64 == nil {
				x.MapFixed32Sfixed64 = make(map[uint32]int64)
			}
			var mapkey uint32
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = uint32(v)
				} else if subNum == 2 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapFixed32Sfixed64[mapkey] = mapvalue
		case 181:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed32Fixed64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapSfixed32Fixed64 == nil {
				x.MapSfixed32Fixed64 = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = uint64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapSfixed32Fixed64[mapkey] = mapvalue
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringBool", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringBool == nil {
				x.MapStringBool = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = bool(v != 0)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringBool[mapkey] = mapvalue
		case 202:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringInt32", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringInt32 == nil {
				x.MapStringInt32 = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int32(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringInt32[mapkey] = mapvalue
		case 203:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringInt64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringInt64 == nil {
				x.MapStringInt64 = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringInt64[mapkey] = mapvalue
		case 204:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringSint64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringSint64 == nil {
				x.MapStringSint64 = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(protowire.DecodeZigZag(v))
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringSint64[mapkey] = mapvalue
		case 205:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringSfixed64", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringSfixed64 == nil {
				x.MapStringSfixed64 = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringSfixed64[mapkey] = mapvalue
		case 206:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringString", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringString == nil {
				x.MapStringString = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = string(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringString[mapkey] = mapvalue
		case 207:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringEnum", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringEnum == nil {
				x.MapStringEnum = make(map[string]TestEnum)
			}
			var mapkey string
			var mapvalue TestEnum
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = TestEnum(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringEnum[mapkey] = mapvalue
		case 231:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MActor", wireType)
			}
			if x.MActor == nil {
				x.MActor = &OtherMessage{}
			}
			if n, err := protohelper.ConsumeMessage(data, x.MActor); err != nil {
				return err
			} else {
				data = data[n:]
			}
		case 232:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrActor", wireType)
			}
			v := &OtherMessage{}
			if n, err := protohelper.ConsumeMessage(data, v); err != nil {
				return err
			} else {
				data = data[n:]
			}
			x.ArrActor = append(x.ArrActor, v)
		case 233:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringActor", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapStringActor == nil {
				x.MapStringActor = make(map[string]*OtherMessage)
			}
			var mapkey string
			var mapvalue *OtherMessage
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					mapvalue = &OtherMessage{}
					n, err := protohelper.ConsumeMessage(data, mapvalue)
					if err != nil {
						return err
					}
					data, msglen = data[n:], msglen-n
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapStringActor[mapkey] = mapvalue
		case 234:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Actor", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt32Actor == nil {
				x.MapInt32Actor = make(map[int32]*OtherMessage)
			}
			var mapkey int32
			var mapvalue *OtherMessage
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					mapvalue = &OtherMessage{}
					n, err := protohelper.ConsumeMessage(data, mapvalue)
					if err != nil {
						return err
					}
					data, msglen = data[n:], msglen-n
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt32Actor[mapkey] = mapvalue
		case 235:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64Actor", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.MapInt64Actor == nil {
				x.MapInt64Actor = make(map[int64]*OtherMessage)
			}
			var mapkey int64
			var mapvalue *OtherMessage
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					mapvalue = &OtherMessage{}
					n, err := protohelper.ConsumeMessage(data, mapvalue)
					if err != nil {
						return err
					}
					data, msglen = data[n:], msglen-n
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.MapInt64Actor[mapkey] = mapvalue
		case 281:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outer", wireType)
			}
			if x.Outer == nil {
				x.Outer = &pb.OuterMsg{}
			}
			if n, err := protohelper.ConsumeMessage(data, x.Outer); err != nil {
				return err
			} else {
				data = data[n:]
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *FullProto) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(FullProto)")
	}
	return len(data), nil
}

func (x *FullProto) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *FullProto) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.VInt32 != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.VInt32))
	}
	if x.VInt64 != 0 {
		data = protowire.AppendVarint(data, 16)
		data = protowire.AppendVarint(data, uint64(x.VInt64))
	}
	if x.VUint32 != 0 {
		data = protowire.AppendVarint(data, 24)
		data = protowire.AppendVarint(data, uint64(x.VUint32))
	}
	if x.VUint64 != 0 {
		data = protowire.AppendVarint(data, 32)
		data = protowire.AppendVarint(data, uint64(x.VUint64))
	}
	if len(x.VString) > 0 {
		data = protowire.AppendVarint(data, 42)
		data = protowire.AppendVarint(data, uint64(len(x.VString)))
		data = append(data, x.VString...)
	}
	if len(x.VBytes) > 0 {
		data = protowire.AppendVarint(data, 162)
		data = protowire.AppendVarint(data, uint64(len(x.VBytes)))
		data = append(data, x.VBytes...)
	}
	if x.VBool {
		data = protowire.AppendVarint(data, 48)
		data = append(data, uint8(protohelper.Bool2Int(x.VBool)))
	}
	if x.SInt32 != 0 {
		data = protowire.AppendVarint(data, 56)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.SInt32)))
	}
	if x.SInt64 != 0 {
		data = protowire.AppendVarint(data, 64)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.SInt64)))
	}
	if x.Fixed32 != 0 {
		data = protowire.AppendVarint(data, 77)
		data = protowire.AppendFixed32(data, uint32(x.Fixed32))
	}
	if x.Fixed64 != 0 {
		data = protowire.AppendVarint(data, 81)
		data = protowire.AppendFixed64(data, uint64(x.Fixed64))
	}
	if x.Sfixed32 != 0 {
		data = protowire.AppendVarint(data, 93)
		data = protowire.AppendFixed32(data, uint32(x.Sfixed32))
	}
	if x.Sfixed64 != 0 {
		data = protowire.AppendVarint(data, 97)
		data = protowire.AppendFixed64(data, uint64(x.Sfixed64))
	}
	if len(x.ArrInt32) > 0 {
		data = protowire.AppendVarint(data, 330)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.ArrInt32)))
		for _, v := range x.ArrInt32 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.ArrInt64) > 0 {
		data = protowire.AppendVarint(data, 338)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.ArrInt64)))
		for _, v := range x.ArrInt64 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.ArrUint32) > 0 {
		data = protowire.AppendVarint(data, 346)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.ArrUint32)))
		for _, v := range x.ArrUint32 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.ArrUint64) > 0 {
		data = protowire.AppendVarint(data, 354)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.ArrUint64)))
		for _, v := range x.ArrUint64 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.ArrBool) > 0 {
		data = protowire.AppendVarint(data, 362)
		data = protowire.AppendVarint(data, uint64(len(x.ArrBool)))
		for _, v := range x.ArrBool {
			data = append(data, uint8(protohelper.Bool2Int(v)))
		}
	}
	if len(x.ArrString) > 0 {
		for _, v := range x.ArrString {
			data = protowire.AppendVarint(data, 370)
			data = append(protowire.AppendVarint(data, uint64(len(v))), v...)
		}
	}
	if len(x.ArrBytes) > 0 {
		for _, v := range x.ArrBytes {
			data = protowire.AppendVarint(data, 378)
			data = append(protowire.AppendVarint(data, uint64(len(v))), v...)
		}
	}
	if len(x.MapInt32Bool) > 0 {
		for k, v := range x.MapInt32Bool {
			data = protowire.AppendVarint(data, 650)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 2
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = append(data, uint8(protohelper.Bool2Int(v)))
		}
	}
	if len(x.MapInt32Int32) > 0 {
		for k, v := range x.MapInt32Int32 {
			data = protowire.AppendVarint(data, 658)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.MapInt32String) > 0 {
		for k, v := range x.MapInt32String {
			data = protowire.AppendVarint(data, 666)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			data = protowire.AppendVarint(data, uint64(len(v)))
			data = append(data, v...)
		}
	}
	if len(x.MapInt64Bool) > 0 {
		for k, v := range x.MapInt64Bool {
			data = protowire.AppendVarint(data, 810)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 2
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = append(data, uint8(protohelper.Bool2Int(v)))
		}
	}
	if len(x.MapInt64Int64) > 0 {
		for k, v := range x.MapInt64Int64 {
			data = protowire.AppendVarint(data, 818)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.MapInt64Bytes) > 0 {
		for k, v := range x.MapInt64Bytes {
			data = protowire.AppendVarint(data, 826)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			data = protowire.AppendVarint(data, uint64(len(v)))
			data = append(data, v...)
		}
	}
	if len(x.MapSint32Sint64) > 0 {
		for k, v := range x.MapSint32Sint64 {
			data = protowire.AppendVarint(data, 970)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(k))) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(k)))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.MapSint64Sint32) > 0 {
		for k, v := range x.MapSint64Sint32 {
			data = protowire.AppendVarint(data, 1130)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(protowire.EncodeZigZag(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(k)))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.MapFixed32Sfixed64) > 0 {
		for k, v := range x.MapFixed32Sfixed64 {
			data = protowire.AppendVarint(data, 1290)
			_, _ = k, v
			l := 5 + 9
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 13)
			data = protowire.AppendFixed32(data, uint32(k))
			data = protowire.AppendVarint(data, 17)
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.MapSfixed32Fixed64) > 0 {
		for k, v := range x.MapSfixed32Fixed64 {
			data = protowire.AppendVarint(data, 1450)
			_, _ = k, v
			l := 5 + 9
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 13)
			data = protowire.AppendFixed32(data, uint32(k))
			data = protowire.AppendVarint(data, 17)
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.MapStringBool) > 0 {
		for k, v := range x.MapStringBool {
			data = protowire.AppendVarint(data, 1610)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 2
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 16)
			data = append(data, uint8(protohelper.Bool2Int(v)))
		}
	}
	if len(x.MapStringInt32) > 0 {
		for k, v := range x.MapStringInt32 {
			data = protowire.AppendVarint(data, 1618)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.MapStringInt64) > 0 {
		for k, v := range x.MapStringInt64 {
			data = protowire.AppendVarint(data, 1626)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.MapStringSint64) > 0 {
		for k, v := range x.MapStringSint64 {
			data = protowire.AppendVarint(data, 1634)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.MapStringSfixed64) > 0 {
		for k, v := range x.MapStringSfixed64 {
			data = protowire.AppendVarint(data, 1642)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 9
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 17)
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.MapStringString) > 0 {
		for k, v := range x.MapStringString {
			data = protowire.AppendVarint(data, 1650)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeBytes(len(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 18)
			data = protowire.AppendVarint(data, uint64(len(v)))
			data = append(data, v...)
		}
	}
	if len(x.MapStringEnum) > 0 {
		for k, v := range x.MapStringEnum {
			data = protowire.AppendVarint(data, 1658)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if x.MActor != nil {
		data = protowire.AppendVarint(data, 1850)
		sz := uint64(fastproto.Size(x.MActor))
		data = protowire.AppendVarint(data, uint64(sz))
		if sz > 0 {
			data, err = fastproto.AppendToSizedBuffer(data, x.MActor)
			if err != nil {
				return nil, err
			}
		}
	}
	if len(x.ArrActor) > 0 {
		for _, v := range x.ArrActor {
			data = protowire.AppendVarint(data, 1858)
			sz := fastproto.Size(v)
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	if len(x.MapStringActor) > 0 {
		for k, v := range x.MapStringActor {
			data = protowire.AppendVarint(data, 1866)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeBytes(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 18)
			sz := uint64(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	if len(x.MapInt32Actor) > 0 {
		for k, v := range x.MapInt32Actor {
			data = protowire.AppendVarint(data, 1874)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			sz := uint64(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	if len(x.MapInt64Actor) > 0 {
		for k, v := range x.MapInt64Actor {
			data = protowire.AppendVarint(data, 1882)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			sz := uint64(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	if x.Outer != nil {
		data = protowire.AppendVarint(data, 2250)
		sz := uint64(fastproto.Size(x.Outer))
		data = protowire.AppendVarint(data, uint64(sz))
		if sz > 0 {
			data, err = fastproto.AppendToSizedBuffer(data, x.Outer)
			if err != nil {
				return nil, err
			}
		}
	}
	return data, nil
}

func (x *FullProto) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*FullProto)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.VInt32 != vv.VInt32 ||
		x.VInt64 != vv.VInt64 ||
		x.VUint32 != vv.VUint32 ||
		x.VUint64 != vv.VUint64 ||
		x.VString != vv.VString ||
		len(x.VBytes) != len(vv.VBytes) ||
		x.VBool != vv.VBool ||
		x.SInt32 != vv.SInt32 ||
		x.SInt64 != vv.SInt64 ||
		x.Fixed32 != vv.Fixed32 ||
		x.Fixed64 != vv.Fixed64 ||
		x.Sfixed32 != vv.Sfixed32 ||
		x.Sfixed64 != vv.Sfixed64 ||
		len(x.ArrInt32) != len(vv.ArrInt32) ||
		len(x.ArrInt64) != len(vv.ArrInt64) ||
		len(x.ArrUint32) != len(vv.ArrUint32) ||
		len(x.ArrUint64) != len(vv.ArrUint64) ||
		len(x.ArrBool) != len(vv.ArrBool) ||
		len(x.ArrString) != len(vv.ArrString) ||
		len(x.ArrBytes) != len(vv.ArrBytes) ||
		len(x.MapInt32Bool) != len(vv.MapInt32Bool) ||
		len(x.MapInt32Int32) != len(vv.MapInt32Int32) ||
		len(x.MapInt32String) != len(vv.MapInt32String) ||
		len(x.MapInt64Bool) != len(vv.MapInt64Bool) ||
		len(x.MapInt64Int64) != len(vv.MapInt64Int64) ||
		len(x.MapInt64Bytes) != len(vv.MapInt64Bytes) ||
		len(x.MapSint32Sint64) != len(vv.MapSint32Sint64) ||
		len(x.MapSint64Sint32) != len(vv.MapSint64Sint32) ||
		len(x.MapFixed32Sfixed64) != len(vv.MapFixed32Sfixed64) ||
		len(x.MapSfixed32Fixed64) != len(vv.MapSfixed32Fixed64) ||
		len(x.MapStringBool) != len(vv.MapStringBool) ||
		len(x.MapStringInt32) != len(vv.MapStringInt32) ||
		len(x.MapStringInt64) != len(vv.MapStringInt64) ||
		len(x.MapStringSint64) != len(vv.MapStringSint64) ||
		len(x.MapStringSfixed64) != len(vv.MapStringSfixed64) ||
		len(x.MapStringString) != len(vv.MapStringString) ||
		len(x.MapStringEnum) != len(vv.MapStringEnum) ||
		len(x.ArrActor) != len(vv.ArrActor) ||
		len(x.MapStringActor) != len(vv.MapStringActor) ||
		len(x.MapInt32Actor) != len(vv.MapInt32Actor) ||
		len(x.MapInt64Actor) != len(vv.MapInt64Actor) {
		return false
	}
	if false ||
		!bytes.Equal(x.VBytes, vv.VBytes) ||
		!protohelper.EqualSlice(x.ArrInt32, vv.ArrInt32) ||
		!protohelper.EqualSlice(x.ArrInt64, vv.ArrInt64) ||
		!protohelper.EqualSlice(x.ArrUint32, vv.ArrUint32) ||
		!protohelper.EqualSlice(x.ArrUint64, vv.ArrUint64) ||
		!protohelper.EqualSlice(x.ArrBool, vv.ArrBool) ||
		!protohelper.EqualSlice(x.ArrString, vv.ArrString) ||
		!protohelper.EqualBytesSlice(x.ArrBytes, vv.ArrBytes) ||
		!protohelper.EqualMap(x.MapInt32Bool, vv.MapInt32Bool) ||
		!protohelper.EqualMap(x.MapInt32Int32, vv.MapInt32Int32) ||
		!protohelper.EqualMap(x.MapInt32String, vv.MapInt32String) ||
		!protohelper.EqualMap(x.MapInt64Bool, vv.MapInt64Bool) ||
		!protohelper.EqualMap(x.MapInt64Int64, vv.MapInt64Int64) ||
		!protohelper.EqualBytesMap(x.MapInt64Bytes, vv.MapInt64Bytes) ||
		!protohelper.EqualMap(x.MapSint32Sint64, vv.MapSint32Sint64) ||
		!protohelper.EqualMap(x.MapSint64Sint32, vv.MapSint64Sint32) ||
		!protohelper.EqualMap(x.MapFixed32Sfixed64, vv.MapFixed32Sfixed64) ||
		!protohelper.EqualMap(x.MapSfixed32Fixed64, vv.MapSfixed32Fixed64) ||
		!protohelper.EqualMap(x.MapStringBool, vv.MapStringBool) ||
		!protohelper.EqualMap(x.MapStringInt32, vv.MapStringInt32) ||
		!protohelper.EqualMap(x.MapStringInt64, vv.MapStringInt64) ||
		!protohelper.EqualMap(x.MapStringSint64, vv.MapStringSint64) ||
		!protohelper.EqualMap(x.MapStringSfixed64, vv.MapStringSfixed64) ||
		!protohelper.EqualMap(x.MapStringString, vv.MapStringString) ||
		!protohelper.EqualMap(x.MapStringEnum, vv.MapStringEnum) ||
		!fastproto.Equal(x.MActor, vv.MActor) ||
		!protohelper.EqualProtoSlice(x.ArrActor, vv.ArrActor) ||
		!protohelper.EqualProtoMap(x.MapStringActor, vv.MapStringActor) ||
		!protohelper.EqualProtoMap(x.MapInt32Actor, vv.MapInt32Actor) ||
		!protohelper.EqualProtoMap(x.MapInt64Actor, vv.MapInt64Actor) ||
		!fastproto.Equal(x.Outer, vv.Outer) {
		return false
	}
	return true
}

func (x *FullProto) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.VInt32 != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.VInt32))
	}
	if x.VInt64 != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.VInt64))
	}
	if x.VUint32 != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.VUint32))
	}
	if x.VUint64 != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.VUint64))
	}
	l = len(x.VString)
	if l > 0 {
		n += 1 + protowire.SizeBytes(l)
	}
	l = len(x.VBytes)
	if l > 0 {
		n += 2 + protowire.SizeBytes(l)
	}
	if x.VBool {
		n += 2
	}
	if x.SInt32 != 0 {
		n += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(x.SInt32)))
	}
	if x.SInt64 != 0 {
		n += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(x.SInt64)))
	}
	if x.Fixed32 != 0 {
		n += 1 + 4
	}
	if x.Fixed64 != 0 {
		n += 1 + 8
	}
	if x.Sfixed32 != 0 {
		n += 1 + 4
	}
	if x.Sfixed64 != 0 {
		n += 1 + 8
	}
	if len(x.ArrInt32) > 0 {
		n += 2 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.ArrInt32))
	}
	if len(x.ArrInt64) > 0 {
		n += 2 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.ArrInt64))
	}
	if len(x.ArrUint32) > 0 {
		n += 2 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.ArrUint32))
	}
	if len(x.ArrUint64) > 0 {
		n += 2 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.ArrUint64))
	}
	if len(x.ArrBool) > 0 {
		n += 2 + protowire.SizeBytes(len(x.ArrBool))
	}
	if len(x.ArrString) > 0 {
		for _, s := range x.ArrString {
			n += 2 + protowire.SizeBytes(len(s))
		}
	}
	if len(x.ArrBytes) > 0 {
		for _, s := range x.ArrBytes {
			n += 2 + protowire.SizeBytes(len(s))
		}
	}
	if len(x.MapInt32Bool) > 0 {
		for k, v := range x.MapInt32Bool {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 2
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt32Int32) > 0 {
		for k, v := range x.MapInt32Int32 {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(uint64(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt32String) > 0 {
		for k, v := range x.MapInt32String {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt64Bool) > 0 {
		for k, v := range x.MapInt64Bool {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 2
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt64Int64) > 0 {
		for k, v := range x.MapInt64Int64 {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(uint64(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt64Bytes) > 0 {
		for k, v := range x.MapInt64Bytes {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapSint32Sint64) > 0 {
		for k, v := range x.MapSint32Sint64 {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(k))) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapSint64Sint32) > 0 {
		for k, v := range x.MapSint64Sint32 {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(protowire.EncodeZigZag(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapFixed32Sfixed64) > 0 {
		for k, v := range x.MapFixed32Sfixed64 {
			_, _ = k, v
			l = 5 + 9
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapSfixed32Fixed64) > 0 {
		for k, v := range x.MapSfixed32Fixed64 {
			_, _ = k, v
			l = 5 + 9
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringBool) > 0 {
		for k, v := range x.MapStringBool {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 2
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringInt32) > 0 {
		for k, v := range x.MapStringInt32 {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(uint64(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringInt64) > 0 {
		for k, v := range x.MapStringInt64 {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(uint64(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringSint64) > 0 {
		for k, v := range x.MapStringSint64 {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringSfixed64) > 0 {
		for k, v := range x.MapStringSfixed64 {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 9
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringString) > 0 {
		for k, v := range x.MapStringString {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeBytes(len(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapStringEnum) > 0 {
		for k, v := range x.MapStringEnum {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 1 + protowire.SizeVarint(uint64(v))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.MActor != nil {
		n += 2 + protowire.SizeBytes(fastproto.Size(x.MActor))
	}
	for _, e := range x.ArrActor {
		n += 2 + protowire.SizeBytes(fastproto.Size(e))
	}
	if len(x.MapStringActor) > 0 {
		for k, v := range x.MapStringActor {
			_, _ = k, v
			sz := fastproto.Size(v)
			l = 1 + protowire.SizeBytes(len(k)) + sz + 1 + protowire.SizeVarint(uint64(sz))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt32Actor) > 0 {
		for k, v := range x.MapInt32Actor {
			_, _ = k, v
			sz := fastproto.Size(v)
			l = 1 + protowire.SizeVarint(uint64(k)) + sz + 1 + protowire.SizeVarint(uint64(sz))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if len(x.MapInt64Actor) > 0 {
		for k, v := range x.MapInt64Actor {
			_, _ = k, v
			sz := fastproto.Size(v)
			l = 1 + protowire.SizeVarint(uint64(k)) + sz + 1 + protowire.SizeVarint(uint64(sz))
			n += 2 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.Outer != nil {
		n += 2 + protowire.SizeBytes(fastproto.Size(x.Outer))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *OtherMessage) XxxReset() {
	*x = OtherMessage{}
}

func (x *OtherMessage) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: OtherMessage: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eid", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Eid = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenId", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.OpenId = string(v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Name = string(v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Job = int32(v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Sex = int32(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *OtherMessage) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(OtherMessage)")
	}
	return len(data), nil
}

func (x *OtherMessage) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *OtherMessage) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Eid != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Eid))
	}
	if len(x.OpenId) > 0 {
		data = protowire.AppendVarint(data, 18)
		data = protowire.AppendVarint(data, uint64(len(x.OpenId)))
		data = append(data, x.OpenId...)
	}
	if len(x.Name) > 0 {
		data = protowire.AppendVarint(data, 26)
		data = protowire.AppendVarint(data, uint64(len(x.Name)))
		data = append(data, x.Name...)
	}
	if x.Job != 0 {
		data = protowire.AppendVarint(data, 32)
		data = protowire.AppendVarint(data, uint64(x.Job))
	}
	if x.Sex != 0 {
		data = protowire.AppendVarint(data, 40)
		data = protowire.AppendVarint(data, uint64(x.Sex))
	}
	return data, nil
}

func (x *OtherMessage) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*OtherMessage)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Eid != vv.Eid ||
		x.OpenId != vv.OpenId ||
		x.Name != vv.Name ||
		x.Job != vv.Job ||
		x.Sex != vv.Sex {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *OtherMessage) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Eid != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Eid))
	}
	l = len(x.OpenId)
	if l > 0 {
		n += 1 + protowire.SizeBytes(l)
	}
	l = len(x.Name)
	if l > 0 {
		n += 1 + protowire.SizeBytes(l)
	}
	if x.Job != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Job))
	}
	if x.Sex != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Sex))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *WithStandardMessage) XxxReset() {
	*x = WithStandardMessage{}
}

func (x *WithStandardMessage) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: WithStandardMessage: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Id = uint64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nofast", wireType)
			}
			if x.Nofast == nil {
				x.Nofast = &pb.NoFastMessage{}
			}
			if n, err := protohelper.ConsumeMessage(data, x.Nofast); err != nil {
				return err
			} else {
				data = data[n:]
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nofasts", wireType)
			}
			v := &pb.NoFastMessage{}
			if n, err := protohelper.ConsumeMessage(data, v); err != nil {
				return err
			} else {
				data = data[n:]
			}
			x.Nofasts = append(x.Nofasts, v)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			if x.LastUpdated == nil {
				x.LastUpdated = &timestamppb.Timestamp{}
			}
			if n, err := protohelper.ConsumeMessage(data, x.LastUpdated); err != nil {
				return err
			} else {
				data = data[n:]
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *WithStandardMessage) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(WithStandardMessage)")
	}
	return len(data), nil
}

func (x *WithStandardMessage) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *WithStandardMessage) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Id != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Id))
	}
	if x.Nofast != nil {
		data = protowire.AppendVarint(data, 18)
		sz := uint64(fastproto.Size(x.Nofast))
		data = protowire.AppendVarint(data, uint64(sz))
		if sz > 0 {
			data, err = fastproto.AppendToSizedBuffer(data, x.Nofast)
			if err != nil {
				return nil, err
			}
		}
	}
	if len(x.Nofasts) > 0 {
		for _, v := range x.Nofasts {
			data = protowire.AppendVarint(data, 26)
			sz := fastproto.Size(v)
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	if x.LastUpdated != nil {
		data = protowire.AppendVarint(data, 34)
		sz := uint64(fastproto.Size(x.LastUpdated))
		data = protowire.AppendVarint(data, uint64(sz))
		if sz > 0 {
			data, err = fastproto.AppendToSizedBuffer(data, x.LastUpdated)
			if err != nil {
				return nil, err
			}
		}
	}
	return data, nil
}

func (x *WithStandardMessage) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*WithStandardMessage)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Id != vv.Id ||
		len(x.Nofasts) != len(vv.Nofasts) {
		return false
	}
	if false ||
		!fastproto.Equal(x.Nofast, vv.Nofast) ||
		!protohelper.EqualProtoSlice(x.Nofasts, vv.Nofasts) ||
		!fastproto.Equal(x.LastUpdated, vv.LastUpdated) {
		return false
	}
	return true
}

func (x *WithStandardMessage) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Id != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Id))
	}
	if x.Nofast != nil {
		n += 1 + protowire.SizeBytes(fastproto.Size(x.Nofast))
	}
	for _, e := range x.Nofasts {
		n += 1 + protowire.SizeBytes(fastproto.Size(e))
	}
	if x.LastUpdated != nil {
		n += 1 + protowire.SizeBytes(fastproto.Size(x.LastUpdated))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *WithAnyMessage) XxxReset() {
	*x = WithAnyMessage{}
}

func (x *WithAnyMessage) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: WithAnyMessage: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Id = uint64(v)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyMsg", wireType)
			}
			if x.AnyMsg == nil {
				x.AnyMsg = &anypb.Any{}
			}
			if n, err := protohelper.ConsumeMessage(data, x.AnyMsg); err != nil {
				return err
			} else {
				data = data[n:]
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.TestOneof = &WithAnyMessage_Name{Name: string(v)}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubMessage", wireType)
			}
			vv := &OtherMessage{}
			if n, err := protohelper.ConsumeMessage(data, vv); err != nil {
				return err
			} else {
				x.TestOneof = &WithAnyMessage_SubMessage{SubMessage: vv}
				data = data[n:]
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *WithAnyMessage) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(WithAnyMessage)")
	}
	return len(data), nil
}

func (x *WithAnyMessage) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *WithAnyMessage) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Id != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Id))
	}
	if x.AnyMsg != nil {
		data = protowire.AppendVarint(data, 34)
		sz := uint64(fastproto.Size(x.AnyMsg))
		data = protowire.AppendVarint(data, uint64(sz))
		if sz > 0 {
			data, err = fastproto.AppendToSizedBuffer(data, x.AnyMsg)
			if err != nil {
				return nil, err
			}
		}
	}
	switch vv := x.GetTestOneof().(type) {
	case *WithAnyMessage_Name:
		if len(vv.Name) > 0 {
			data = protowire.AppendVarint(data, 42)
			data = protowire.AppendVarint(data, uint64(len(vv.Name)))
			data = append(data, vv.Name...)
		}
	case *WithAnyMessage_SubMessage:
		if vv.SubMessage != nil {
			data = protowire.AppendVarint(data, 74)
			sz := uint64(fastproto.Size(vv.SubMessage))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, vv.SubMessage)
				if err != nil {
					return nil, err
				}
			}
		}
	default:
	}
	return data, nil
}

func (x *WithAnyMessage) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*WithAnyMessage)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Id != vv.Id {
		return false
	}
	if false ||
		!fastproto.Equal(x.AnyMsg, vv.AnyMsg) {
		return false
	}
	switch xx := x.GetTestOneof().(type) {
	case *WithAnyMessage_Name:
		if vv2, ok := vv.GetTestOneof().(*WithAnyMessage_Name); !ok {
			return false
		} else if vv2.Name != xx.Name {
			return false
		}
	case *WithAnyMessage_SubMessage:
		if vv2, ok := vv.GetTestOneof().(*WithAnyMessage_SubMessage); !ok {
			return false
		} else if !fastproto.Equal(vv2.SubMessage, xx.SubMessage) {
			return false
		}
	default:
	}
	return true
}

func (x *WithAnyMessage) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Id != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Id))
	}
	if x.AnyMsg != nil {
		n += 1 + protowire.SizeBytes(fastproto.Size(x.AnyMsg))
	}
	switch vv := x.GetTestOneof().(type) {
	case *WithAnyMessage_Name:
		l = len(vv.Name)
		if l > 0 {
			n += 1 + protowire.SizeBytes(l)
		}
	case *WithAnyMessage_SubMessage:
		if vv.SubMessage != nil {
			n += 1 + protowire.SizeBytes(fastproto.Size(vv.SubMessage))
		}
	default:
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Float) XxxReset() {
	*x = Float{}
}

func (x *Float) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: float: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeFixed32(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = math.Float32frombits(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Float) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Float)")
	}
	return len(data), nil
}

func (x *Float) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Float) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 13)
		data = protowire.AppendFixed32(data, uint32(math.Float32bits(x.Val)))
	}
	return data, nil
}

func (x *Float) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Float)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Float) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + 4
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Double) XxxReset() {
	*x = Double{}
}

func (x *Double) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: double: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeFixed64(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = math.Float64frombits(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Double) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Double)")
	}
	return len(data), nil
}

func (x *Double) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Double) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 9)
		data = protowire.AppendFixed64(data, uint64(math.Float64bits(x.Val)))
	}
	return data, nil
}

func (x *Double) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Double)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Double) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + 8
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Int32) XxxReset() {
	*x = Int32{}
}

func (x *Int32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: int32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = int32(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Int32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Int32)")
	}
	return len(data), nil
}

func (x *Int32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Int32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Val))
	}
	return data, nil
}

func (x *Int32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Int32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Int32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Int64) XxxReset() {
	*x = Int64{}
}

func (x *Int64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: int64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = int64(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Int64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Int64)")
	}
	return len(data), nil
}

func (x *Int64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Int64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Val))
	}
	return data, nil
}

func (x *Int64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Int64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Int64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sint32) XxxReset() {
	*x = Sint32{}
}

func (x *Sint32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sint32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = int32(protowire.DecodeZigZag(v))
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sint32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sint32)")
	}
	return len(data), nil
}

func (x *Sint32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sint32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.Val)))
	}
	return data, nil
}

func (x *Sint32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sint32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Sint32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(x.Val)))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sint64) XxxReset() {
	*x = Sint64{}
}

func (x *Sint64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sint64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = int64(protowire.DecodeZigZag(v))
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sint64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sint64)")
	}
	return len(data), nil
}

func (x *Sint64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sint64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.Val)))
	}
	return data, nil
}

func (x *Sint64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sint64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Sint64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(x.Val)))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Uint32) XxxReset() {
	*x = Uint32{}
}

func (x *Uint32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: uint32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = uint32(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Uint32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Uint32)")
	}
	return len(data), nil
}

func (x *Uint32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Uint32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Val))
	}
	return data, nil
}

func (x *Uint32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Uint32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Uint32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Uint64) XxxReset() {
	*x = Uint64{}
}

func (x *Uint64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: uint64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = uint64(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Uint64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Uint64)")
	}
	return len(data), nil
}

func (x *Uint64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Uint64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 8)
		data = protowire.AppendVarint(data, uint64(x.Val))
	}
	return data, nil
}

func (x *Uint64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Uint64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Uint64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Fixed32) XxxReset() {
	*x = Fixed32{}
}

func (x *Fixed32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: fixed32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeFixed32(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = uint32(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Fixed32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Fixed32)")
	}
	return len(data), nil
}

func (x *Fixed32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Fixed32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 13)
		data = protowire.AppendFixed32(data, uint32(x.Val))
	}
	return data, nil
}

func (x *Fixed32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Fixed32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Fixed32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + 4
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Fixed64) XxxReset() {
	*x = Fixed64{}
}

func (x *Fixed64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: fixed64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeFixed64(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = uint64(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Fixed64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Fixed64)")
	}
	return len(data), nil
}

func (x *Fixed64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Fixed64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 9)
		data = protowire.AppendFixed64(data, uint64(x.Val))
	}
	return data, nil
}

func (x *Fixed64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Fixed64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Fixed64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + 8
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sfixed32) XxxReset() {
	*x = Sfixed32{}
}

func (x *Sfixed32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sfixed32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeFixed32(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = int32(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sfixed32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sfixed32)")
	}
	return len(data), nil
}

func (x *Sfixed32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sfixed32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 13)
		data = protowire.AppendFixed32(data, uint32(x.Val))
	}
	return data, nil
}

func (x *Sfixed32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sfixed32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Sfixed32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + 4
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sfixed64) XxxReset() {
	*x = Sfixed64{}
}

func (x *Sfixed64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sfixed64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeFixed64(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = int64(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sfixed64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sfixed64)")
	}
	return len(data), nil
}

func (x *Sfixed64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sfixed64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != 0 {
		data = protowire.AppendVarint(data, 9)
		data = protowire.AppendFixed64(data, uint64(x.Val))
	}
	return data, nil
}

func (x *Sfixed64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sfixed64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Sfixed64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != 0 {
		n += 1 + 8
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Bool) XxxReset() {
	*x = Bool{}
}

func (x *Bool) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: bool: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = bool(v != 0)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Bool) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Bool)")
	}
	return len(data), nil
}

func (x *Bool) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Bool) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val {
		data = protowire.AppendVarint(data, 8)
		data = append(data, uint8(protohelper.Bool2Int(x.Val)))
	}
	return data, nil
}

func (x *Bool) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Bool)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *Bool) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val {
		n += 2
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *String) XxxReset() {
	*x = String{}
}

func (x *String) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: string: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = string(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *String) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(String)")
	}
	return len(data), nil
}

func (x *String) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *String) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(len(x.Val)))
		data = append(data, x.Val...)
	}
	return data, nil
}

func (x *String) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*String)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val != vv.Val {
		return false
	}
	if false {
		return false
	}
	return true
}

func (x *String) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	l = len(x.Val)
	if l > 0 {
		n += 1 + protowire.SizeBytes(l)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Bytes) XxxReset() {
	*x = Bytes{}
}

func (x *Bytes) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: bytes: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = append(x.Val[:0], v...)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Bytes) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Bytes)")
	}
	return len(data), nil
}

func (x *Bytes) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Bytes) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(len(x.Val)))
		data = append(data, x.Val...)
	}
	return data, nil
}

func (x *Bytes) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Bytes)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!bytes.Equal(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Bytes) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	l = len(x.Val)
	if l > 0 {
		n += 1 + protowire.SizeBytes(l)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *TestProtoMsg) XxxReset() {
	*x = TestProtoMsg{}
}

func (x *TestProtoMsg) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: TestProtoMsg: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			if x.Val == nil {
				x.Val = &OtherMessage{}
			}
			if n, err := protohelper.ConsumeMessage(data, x.Val); err != nil {
				return err
			} else {
				data = data[n:]
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val2", wireType)
			}
			v, n := protowire.ConsumeVarint(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val2 = TestEnum(v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *TestProtoMsg) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(TestProtoMsg)")
	}
	return len(data), nil
}

func (x *TestProtoMsg) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *TestProtoMsg) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if x.Val != nil {
		data = protowire.AppendVarint(data, 10)
		sz := uint64(fastproto.Size(x.Val))
		data = protowire.AppendVarint(data, uint64(sz))
		if sz > 0 {
			data, err = fastproto.AppendToSizedBuffer(data, x.Val)
			if err != nil {
				return nil, err
			}
		}
	}
	if x.Val2 != 0 {
		data = protowire.AppendVarint(data, 16)
		data = protowire.AppendVarint(data, uint64(x.Val2))
	}
	return data, nil
}

func (x *TestProtoMsg) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*TestProtoMsg)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		x.Val2 != vv.Val2 {
		return false
	}
	if false ||
		!fastproto.Equal(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *TestProtoMsg) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if x.Val != nil {
		n += 1 + protowire.SizeBytes(fastproto.Size(x.Val))
	}
	if x.Val2 != 0 {
		n += 1 + protowire.SizeVarint(uint64(x.Val2))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Floats) XxxReset() {
	*x = Floats{}
}

func (x *Floats) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: floats: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 5 {
				v, n := protowire.ConsumeFixed32(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, math.Float32frombits(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen / 4
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]float32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, math.Float32frombits(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Floats) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Floats)")
	}
	return len(data), nil
}

func (x *Floats) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Floats) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(4*len(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendFixed32(data, uint32(math.Float32bits(v)))
		}
	}
	return data, nil
}

func (x *Floats) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Floats)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Floats) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val)*4)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Doubles) XxxReset() {
	*x = Doubles{}
}

func (x *Doubles) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: doubles: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 1 {
				v, n := protowire.ConsumeFixed64(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, math.Float64frombits(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen / 8
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]float64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, math.Float64frombits(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Doubles) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Doubles)")
	}
	return len(data), nil
}

func (x *Doubles) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Doubles) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(8*len(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendFixed64(data, uint64(math.Float64bits(v)))
		}
	}
	return data, nil
}

func (x *Doubles) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Doubles)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Doubles) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val)*8)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Int32S) XxxReset() {
	*x = Int32S{}
}

func (x *Int32S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: int32s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, int32(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]int32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, int32(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Int32S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Int32S)")
	}
	return len(data), nil
}

func (x *Int32S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Int32S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Int32S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Int32S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Int32S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Int64S) XxxReset() {
	*x = Int64S{}
}

func (x *Int64S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: int64s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, int64(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]int64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Int64S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Int64S)")
	}
	return len(data), nil
}

func (x *Int64S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Int64S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Int64S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Int64S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Int64S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sint32S) XxxReset() {
	*x = Sint32S{}
}

func (x *Sint32S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sint32s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, int32(protowire.DecodeZigZag(v)))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]int32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, int32(protowire.DecodeZigZag(v)))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sint32S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sint32S)")
	}
	return len(data), nil
}

func (x *Sint32S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sint32S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeZigZagSlice(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	return data, nil
}

func (x *Sint32S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sint32S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Sint32S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(protohelper.SizeZigZagSlice(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sint64S) XxxReset() {
	*x = Sint64S{}
}

func (x *Sint64S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sint64s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, int64(protowire.DecodeZigZag(v)))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]int64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, int64(protowire.DecodeZigZag(v)))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sint64S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sint64S)")
	}
	return len(data), nil
}

func (x *Sint64S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sint64S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeZigZagSlice(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	return data, nil
}

func (x *Sint64S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sint64S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Sint64S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(protohelper.SizeZigZagSlice(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Uint32S) XxxReset() {
	*x = Uint32S{}
}

func (x *Uint32S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: uint32s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, uint32(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]uint32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, uint32(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Uint32S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Uint32S)")
	}
	return len(data), nil
}

func (x *Uint32S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Uint32S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Uint32S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Uint32S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Uint32S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Uint64S) XxxReset() {
	*x = Uint64S{}
}

func (x *Uint64S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: uint64s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, uint64(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]uint64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, uint64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Uint64S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Uint64S)")
	}
	return len(data), nil
}

func (x *Uint64S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Uint64S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(protohelper.SizeVarintSlice(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Uint64S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Uint64S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Uint64S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(protohelper.SizeVarintSlice(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Fixed32S) XxxReset() {
	*x = Fixed32S{}
}

func (x *Fixed32S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: fixed32s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 5 {
				v, n := protowire.ConsumeFixed32(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, uint32(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen / 4
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]uint32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, uint32(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Fixed32S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Fixed32S)")
	}
	return len(data), nil
}

func (x *Fixed32S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Fixed32S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(4*len(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	return data, nil
}

func (x *Fixed32S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Fixed32S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Fixed32S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val)*4)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Fixed64S) XxxReset() {
	*x = Fixed64S{}
}

func (x *Fixed64S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: fixed64s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 1 {
				v, n := protowire.ConsumeFixed64(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, uint64(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen / 8
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]uint64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, uint64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Fixed64S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Fixed64S)")
	}
	return len(data), nil
}

func (x *Fixed64S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Fixed64S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(8*len(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Fixed64S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Fixed64S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Fixed64S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val)*8)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sfixed32S) XxxReset() {
	*x = Sfixed32S{}
}

func (x *Sfixed32S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sfixed32s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 5 {
				v, n := protowire.ConsumeFixed32(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, int32(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen / 4
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]int32, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, int32(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sfixed32S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sfixed32S)")
	}
	return len(data), nil
}

func (x *Sfixed32S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sfixed32S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(4*len(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	return data, nil
}

func (x *Sfixed32S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sfixed32S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Sfixed32S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val)*4)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Sfixed64S) XxxReset() {
	*x = Sfixed64S{}
}

func (x *Sfixed64S) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: sfixed64s: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 1 {
				v, n := protowire.ConsumeFixed64(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, int64(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen / 8
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]int64, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Sfixed64S) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Sfixed64S)")
	}
	return len(data), nil
}

func (x *Sfixed64S) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Sfixed64S) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(8*len(x.Val)))
		for _, v := range x.Val {
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Sfixed64S) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Sfixed64S)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Sfixed64S) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val)*8)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Bools) XxxReset() {
	*x = Bools{}
}

func (x *Bools) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: bools: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, v != 0)
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := msglen
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]bool, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, v != 0)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Bools) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Bools)")
	}
	return len(data), nil
}

func (x *Bools) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Bools) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		data = protowire.AppendVarint(data, uint64(len(x.Val)))
		for _, v := range x.Val {
			data = append(data, uint8(protohelper.Bool2Int(v)))
		}
	}
	return data, nil
}

func (x *Bools) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Bools)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Bools) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		n += 1 + protowire.SizeBytes(len(x.Val))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Strings) XxxReset() {
	*x = Strings{}
}

func (x *Strings) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: strings: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = append(x.Val, string(v))
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Strings) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Strings)")
	}
	return len(data), nil
}

func (x *Strings) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Strings) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			data = append(protowire.AppendVarint(data, uint64(len(v))), v...)
		}
	}
	return data, nil
}

func (x *Strings) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Strings)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Strings) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for _, s := range x.Val {
			n += 1 + protowire.SizeBytes(len(s))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Bytess) XxxReset() {
	*x = Bytess{}
}

func (x *Bytess) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: bytess: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v, n := protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			x.Val = append(x.Val[:], append([]byte{}, v...))
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Bytess) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Bytess)")
	}
	return len(data), nil
}

func (x *Bytess) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Bytess) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			data = append(protowire.AppendVarint(data, uint64(len(v))), v...)
		}
	}
	return data, nil
}

func (x *Bytess) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Bytess)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualBytesSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Bytess) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for _, s := range x.Val {
			n += 1 + protowire.SizeBytes(len(s))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *TestProtoMsgs) XxxReset() {
	*x = TestProtoMsgs{}
}

func (x *TestProtoMsgs) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: TestProtoMsgs: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			v := &OtherMessage{}
			if n, err := protohelper.ConsumeMessage(data, v); err != nil {
				return err
			} else {
				data = data[n:]
			}
			x.Val = append(x.Val, v)
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *TestProtoMsgs) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(TestProtoMsgs)")
	}
	return len(data), nil
}

func (x *TestProtoMsgs) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *TestProtoMsgs) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			sz := fastproto.Size(v)
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	return data, nil
}

func (x *TestProtoMsgs) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*TestProtoMsgs)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualProtoSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *TestProtoMsgs) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	for _, e := range x.Val {
		n += 1 + protowire.SizeBytes(fastproto.Size(e))
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *TestEnums) XxxReset() {
	*x = TestEnums{}
}

func (x *TestEnums) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: TestEnums: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType == 0 {
				v, n := protowire.ConsumeVarint(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				x.Val = append(x.Val, TestEnum(v))
			} else if wireType == 2 {
				msglen, n := protohelper.CalcListLength(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data = data[n:]
				elementCount := 0
				for _, i := range data[:msglen] {
					if i < 128 {
						elementCount++
					}
				}
				if elementCount != 0 && len(x.Val) == 0 {
					x.Val = make([]TestEnum, 0, elementCount)
				}
				for elementCount > 0 {
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data = data[n:]
					elementCount--
					x.Val = append(x.Val, TestEnum(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *TestEnums) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(TestEnums)")
	}
	return len(data), nil
}

func (x *TestEnums) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *TestEnums) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		data = protowire.AppendVarint(data, 10)
		sz := 0
		for _, v := range x.Val {
			sz += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(sz))
		for _, v := range x.Val {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *TestEnums) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*TestEnums)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualSlice(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *TestEnums) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		l = 0
		for _, v := range x.Val {
			l += protowire.SizeVarint(uint64(v))
		}
		n += 1 + protowire.SizeBytes(l)
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapint32Fixed64) XxxReset() {
	*x = Mapint32Fixed64{}
}

func (x *Mapint32Fixed64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapint32fixed64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = uint64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapint32Fixed64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapint32Fixed64)")
	}
	return len(data), nil
}

func (x *Mapint32Fixed64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapint32Fixed64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 9
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 17)
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Mapint32Fixed64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapint32Fixed64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapint32Fixed64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 9
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapint64Fixed32) XxxReset() {
	*x = Mapint64Fixed32{}
}

func (x *Mapint64Fixed32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapint64fixed32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64]uint32)
			}
			var mapkey int64
			var mapvalue uint32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = uint32(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapint64Fixed32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapint64Fixed32)")
	}
	return len(data), nil
}

func (x *Mapint64Fixed32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapint64Fixed32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 5
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 21)
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	return data, nil
}

func (x *Mapint64Fixed32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapint64Fixed32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapint64Fixed32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 5
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapuint32Sint64) XxxReset() {
	*x = Mapuint32Sint64{}
}

func (x *Mapuint32Sint64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapuint32sint64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[uint32]int64)
			}
			var mapkey uint32
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = uint32(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(protowire.DecodeZigZag(v))
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapuint32Sint64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapuint32Sint64)")
	}
	return len(data), nil
}

func (x *Mapuint32Sint64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapuint32Sint64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	return data, nil
}

func (x *Mapuint32Sint64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapuint32Sint64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapuint32Sint64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapuint64Sint32) XxxReset() {
	*x = Mapuint64Sint32{}
}

func (x *Mapuint64Sint32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapuint64sint32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[uint64]int32)
			}
			var mapkey uint64
			var mapvalue int32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = uint64(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int32(protowire.DecodeZigZag(v))
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapuint64Sint32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapuint64Sint32)")
	}
	return len(data), nil
}

func (x *Mapuint64Sint32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapuint64Sint32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	return data, nil
}

func (x *Mapuint64Sint32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapuint64Sint32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapuint64Sint32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *MapSint32Int64) XxxReset() {
	*x = MapSint32Int64{}
}

func (x *MapSint32Int64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapSint32Int64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(protowire.DecodeZigZag(v))
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *MapSint32Int64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(MapSint32Int64)")
	}
	return len(data), nil
}

func (x *MapSint32Int64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *MapSint32Int64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(k))) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(k)))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *MapSint32Int64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*MapSint32Int64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *MapSint32Int64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(k))) + 1 + protowire.SizeVarint(uint64(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *MapSint64Int32) XxxReset() {
	*x = MapSint64Int32{}
}

func (x *MapSint64Int32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapSint64Int32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(protowire.DecodeZigZag(v))
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int32(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *MapSint64Int32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(MapSint64Int32)")
	}
	return len(data), nil
}

func (x *MapSint64Int32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *MapSint64Int32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(protowire.EncodeZigZag(k)) + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(k)))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *MapSint64Int32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*MapSint64Int32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *MapSint64Int32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(protowire.EncodeZigZag(k)) + 1 + protowire.SizeVarint(uint64(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *MapFixed32Double) XxxReset() {
	*x = MapFixed32Double{}
}

func (x *MapFixed32Double) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapFixed32Double: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[uint32]float64)
			}
			var mapkey uint32
			var mapvalue float64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = uint32(v)
				} else if subNum == 2 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = math.Float64frombits(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *MapFixed32Double) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(MapFixed32Double)")
	}
	return len(data), nil
}

func (x *MapFixed32Double) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *MapFixed32Double) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 5 + 9
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 13)
			data = protowire.AppendFixed32(data, uint32(k))
			data = protowire.AppendVarint(data, 17)
			data = protowire.AppendFixed64(data, uint64(math.Float64bits(v)))
		}
	}
	return data, nil
}

func (x *MapFixed32Double) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*MapFixed32Double)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *MapFixed32Double) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 5 + 9
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *MapFixed64Float) XxxReset() {
	*x = MapFixed64Float{}
}

func (x *MapFixed64Float) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapFixed64Float: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[uint64]float32)
			}
			var mapkey uint64
			var mapvalue float32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = uint64(v)
				} else if subNum == 2 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = math.Float32frombits(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *MapFixed64Float) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(MapFixed64Float)")
	}
	return len(data), nil
}

func (x *MapFixed64Float) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *MapFixed64Float) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 9 + 5
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 9)
			data = protowire.AppendFixed64(data, uint64(k))
			data = protowire.AppendVarint(data, 21)
			data = protowire.AppendFixed32(data, uint32(math.Float32bits(v)))
		}
	}
	return data, nil
}

func (x *MapFixed64Float) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*MapFixed64Float)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *MapFixed64Float) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 9 + 5
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapsfixed64Uint32) XxxReset() {
	*x = Mapsfixed64Uint32{}
}

func (x *Mapsfixed64Uint32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapsfixed64uint32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64]uint32)
			}
			var mapkey int64
			var mapvalue uint32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = uint32(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapsfixed64Uint32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapsfixed64Uint32)")
	}
	return len(data), nil
}

func (x *Mapsfixed64Uint32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapsfixed64Uint32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 9 + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 9)
			data = protowire.AppendFixed64(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Mapsfixed64Uint32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapsfixed64Uint32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapsfixed64Uint32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 9 + 1 + protowire.SizeVarint(uint64(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapsfixed32Uint64) XxxReset() {
	*x = Mapsfixed32Uint64{}
}

func (x *Mapsfixed32Uint64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapsfixed32uint64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int32(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = uint64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapsfixed32Uint64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapsfixed32Uint64)")
	}
	return len(data), nil
}

func (x *Mapsfixed32Uint64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapsfixed32Uint64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 5 + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 13)
			data = protowire.AppendFixed32(data, uint32(k))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Mapsfixed32Uint64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapsfixed32Uint64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapsfixed32Uint64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 5 + 1 + protowire.SizeVarint(uint64(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapstringsfixed32) XxxReset() {
	*x = Mapstringsfixed32{}
}

func (x *Mapstringsfixed32) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapstringsfixed32: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 5 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed32(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int32(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapstringsfixed32) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapstringsfixed32)")
	}
	return len(data), nil
}

func (x *Mapstringsfixed32) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapstringsfixed32) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 5
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 21)
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	return data, nil
}

func (x *Mapstringsfixed32) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapstringsfixed32)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapstringsfixed32) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 5
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapstringsfixed64) XxxReset() {
	*x = Mapstringsfixed64{}
}

func (x *Mapstringsfixed64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapstringsfixed64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = string(v)
				} else if subNum == 2 {
					if subWireType != 1 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeFixed64(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapstringsfixed64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapstringsfixed64)")
	}
	return len(data), nil
}

func (x *Mapstringsfixed64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapstringsfixed64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeBytes(len(k)) + 9
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 10)
			data = protowire.AppendVarint(data, uint64(len(k)))
			data = append(data, k...)
			data = protowire.AppendVarint(data, 17)
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	return data, nil
}

func (x *Mapstringsfixed64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapstringsfixed64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapstringsfixed64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeBytes(len(k)) + 9
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapint64String) XxxReset() {
	*x = Mapint64String{}
}

func (x *Mapint64String) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapint64string: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = string(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapint64String) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapint64String)")
	}
	return len(data), nil
}

func (x *Mapint64String) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapint64String) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			data = protowire.AppendVarint(data, uint64(len(v)))
			data = append(data, v...)
		}
	}
	return data, nil
}

func (x *Mapint64String) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapint64String)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapint64String) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapint64Bytes) XxxReset() {
	*x = Mapint64Bytes{}
}

func (x *Mapint64Bytes) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapint64bytes: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64][]byte)
			}
			var mapkey int64
			var mapvalue []byte
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeBytes(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = []byte(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapint64Bytes) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapint64Bytes)")
	}
	return len(data), nil
}

func (x *Mapint64Bytes) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapint64Bytes) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			data = protowire.AppendVarint(data, uint64(len(v)))
			data = append(data, v...)
		}
	}
	return data, nil
}

func (x *Mapint64Bytes) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapint64Bytes)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualBytesMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapint64Bytes) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(len(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapint64Bool) XxxReset() {
	*x = Mapint64Bool{}
}

func (x *Mapint64Bool) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapint64bool: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = bool(v != 0)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapint64Bool) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapint64Bool)")
	}
	return len(data), nil
}

func (x *Mapint64Bool) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapint64Bool) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 2
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 16)
			data = append(data, uint8(protohelper.Bool2Int(v)))
		}
	}
	return data, nil
}

func (x *Mapint64Bool) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapint64Bool)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapint64Bool) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 1 + protowire.SizeVarint(uint64(k)) + 2
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *MapBoolInt64) XxxReset() {
	*x = MapBoolInt64{}
}

func (x *MapBoolInt64) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapBoolInt64: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[bool]int64)
			}
			var mapkey bool
			var mapvalue int64
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = bool(v != 0)
				} else if subNum == 2 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapvalue = int64(v)
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *MapBoolInt64) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(MapBoolInt64)")
	}
	return len(data), nil
}

func (x *MapBoolInt64) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *MapBoolInt64) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 2 + 1 + protowire.SizeVarint(uint64(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = append(data, uint8(protohelper.Bool2Int(k)))
			data = protowire.AppendVarint(data, 16)
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	return data, nil
}

func (x *MapBoolInt64) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*MapBoolInt64)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *MapBoolInt64) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			l = 2 + 1 + protowire.SizeVarint(uint64(v))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}

func (x *Mapint64TestProtoMsg) XxxReset() {
	*x = Mapint64TestProtoMsg{}
}

func (x *Mapint64TestProtoMsg) Unmarshal(data []byte) error {
	for len(data) > 0 {
		num, wireType, n := protowire.ConsumeTag(data)
		if n < 0 {
			return protowire.ParseError(n)
		}
		if num <= 0 {
			return fmt.Errorf("proto: mapint64TestProtoMsg: illegal tag %d (wire type %d)", num, wireType)
		}
		data = data[n:]
		switch num {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			msglen, n := protohelper.CalcListLength(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			data = data[n:]
			if x.Val == nil {
				x.Val = make(map[int64]*OtherMessage)
			}
			var mapkey int64
			var mapvalue *OtherMessage
			for msglen > 0 {
				subNum, subWireType, n := protowire.ConsumeTag(data)
				if n < 0 {
					return protowire.ParseError(n)
				}
				data, msglen = data[n:], msglen-n
				if subNum == 1 {
					if subWireType != 0 {
						return fmt.Errorf("proto: wrong wireType = %d for field key", subWireType)
					}
					v, n := protowire.ConsumeVarint(data)
					if n < 0 {
						return protowire.ParseError(n)
					}
					data, msglen = data[n:], msglen-n
					mapkey = int64(v)
				} else if subNum == 2 {
					if subWireType != 2 {
						return fmt.Errorf("proto: wrong wireType = %d for field value", subWireType)
					}
					mapvalue = &OtherMessage{}
					n, err := protohelper.ConsumeMessage(data, mapvalue)
					if err != nil {
						return err
					}
					data, msglen = data[n:], msglen-n
				} else {
					if skippy, err := protohelper.Skip(data); err != nil {
						return err
					} else {
						data = data[skippy:]
						msglen -= skippy
					}
				}
			}
			x.Val[mapkey] = mapvalue
		default:
			_, n = protowire.ConsumeBytes(data)
			if n < 0 {
				return protowire.ParseError(n)
			}
			x.unknownFields = append(x.unknownFields, data[:n]...)
			data = data[n:]
		}
	}
	return nil
}

func (x *Mapint64TestProtoMsg) MarshalTo(data []byte) (n int, err error) {
	maxN := cap(data)
	data, err = x.AppendToSizedBuffer(data[:0])
	if maxN < len(data) {
		return 0, fmt.Errorf("Not enough space for message(Mapint64TestProtoMsg)")
	}
	return len(data), nil
}

func (x *Mapint64TestProtoMsg) Marshal() ([]byte, error) {
	data := make([]byte, 0, fastproto.Size(x))
	data, err := x.AppendToSizedBuffer(data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func (x *Mapint64TestProtoMsg) AppendToSizedBuffer(data []byte) (ret []byte, err error) {
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			data = protowire.AppendVarint(data, 10)
			_, _ = k, v
			l := 1 + protowire.SizeVarint(uint64(k)) + 1 + protowire.SizeBytes(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(l))
			data = protowire.AppendVarint(data, 8)
			data = protowire.AppendVarint(data, uint64(k))
			data = protowire.AppendVarint(data, 18)
			sz := uint64(fastproto.Size(v))
			data = protowire.AppendVarint(data, uint64(sz))
			if sz > 0 {
				data, err = fastproto.AppendToSizedBuffer(data, v)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	return data, nil
}

func (x *Mapint64TestProtoMsg) Equal(v2 proto.Message) bool {
	vv, ok := v2.(*Mapint64TestProtoMsg)
	if !ok {
		return false
	}
	if x == nil || vv == nil {
		return x == vv
	}
	if x == vv {
		return true
	}
	if false ||
		len(x.Val) != len(vv.Val) {
		return false
	}
	if false ||
		!protohelper.EqualProtoMap(x.Val, vv.Val) {
		return false
	}
	return true
}

func (x *Mapint64TestProtoMsg) Size() (n int) {
	if x == nil {
		return 0
	}
	var l int
	_ = l
	if len(x.Val) > 0 {
		for k, v := range x.Val {
			_, _ = k, v
			sz := fastproto.Size(v)
			l = 1 + protowire.SizeVarint(uint64(k)) + sz + 1 + protowire.SizeVarint(uint64(sz))
			n += 1 + l + protowire.SizeVarint(uint64(l))
		}
	}
	if x.unknownFields != nil {
		n += len(x.unknownFields)
	}
	x.sizeCache = int32(n)
	return
}
